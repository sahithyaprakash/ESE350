   1               		.file	"util.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 109               	.global	uart_init
 111               	uart_init:
 112               		.stabd	46,0,0
   1:util.c        **** // general purpose stuff, use as you'd like!
   2:util.c        **** 
   3:util.c        **** #include <avr/io.h>
   4:util.c        **** #include <avr/interrupt.h>
   5:util.c        **** #include <util/delay.h>
   6:util.c        **** #include <avr/pgmspace.h>
   7:util.c        **** #include "util.h"
   8:util.c        **** 
   9:util.c        **** // Creates a 8N1 UART connect
  10:util.c        **** // remember that the BBR is #defined for each F_CPU in util.h
  11:util.c        **** void uart_init(uint16_t BRR) {
 114               	.LM0:
 115               	.LFBB1:
 116               	/* prologue: function */
 117               	/* frame size = 0 */
 118               	/* stack size = 0 */
 119               	.L__stack_usage = 0
  12:util.c        ****   UBRR0 = BRR;               // set baudrate counter
 121               	.LM1:
 122 0000 9093 C500 		sts 196+1,r25
 123 0004 8093 C400 		sts 196,r24
  13:util.c        **** 
  14:util.c        ****   UCSR0B = _BV(RXEN0) | _BV(TXEN0);
 125               	.LM2:
 126 0008 88E1      		ldi r24,lo8(24)
 127 000a 8093 C100 		sts 193,r24
  15:util.c        ****   UCSR0C = _BV(USBS0) | (3 << UCSZ00);
 129               	.LM3:
 130 000e 8EE0      		ldi r24,lo8(14)
 131 0010 8093 C200 		sts 194,r24
  16:util.c        ****   DDRD |= _BV(1);
 133               	.LM4:
 134 0014 519A      		sbi 0xa,1
  17:util.c        ****   DDRD &= ~_BV(0);
 136               	.LM5:
 137 0016 5098      		cbi 0xa,0
 138 0018 0895      		ret
 140               	.Lscope1:
 142               		.stabd	78,0,0
 145               	.global	delay_10us
 147               	delay_10us:
 148               		.stabd	46,0,0
  18:util.c        **** }
  19:util.c        **** 
  20:util.c        **** // Some basic delays...
  21:util.c        **** void delay_10us(uint8_t ns)
  22:util.c        **** {
 150               	.LM6:
 151               	.LFBB2:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
 156               	.L3:
  23:util.c        ****   uint8_t i;
  24:util.c        **** 
  25:util.c        ****   while (ns != 0) {
 158               	.LM7:
 159 001a 8823      		tst r24
 160 001c 01F0      		breq .L8
  26:util.c        ****     ns--;
 162               	.LM8:
 163 001e 8150      		subi r24,lo8(-(-1))
 164 0020 9EE1      		ldi r25,lo8(30)
 165               	.L4:
  27:util.c        ****     for (i = 0; i < 30; i++) {
  28:util.c        ****       nop;
 167               	.LM9:
 168               	/* #APP */
 169               	 ;  28 "util.c" 1
 170 0022 0000      		nop
 171               		
 172               	 ;  0 "" 2
 173               	/* #NOAPP */
 174 0024 9150      		subi r25,lo8(-(-1))
  27:util.c        ****     for (i = 0; i < 30; i++) {
 176               	.LM10:
 177 0026 01F4      		brne .L4
 178 0028 00C0      		rjmp .L3
 179               	.L8:
 180               	/* epilogue start */
  29:util.c        ****     }
  30:util.c        ****   }
  31:util.c        **** }
 182               	.LM11:
 183 002a 0895      		ret
 185               	.Lscope2:
 187               		.stabd	78,0,0
 190               	.global	delay_s
 192               	delay_s:
 193               		.stabd	46,0,0
  32:util.c        **** 
  33:util.c        **** void delay_s(uint8_t s) {
 195               	.LM12:
 196               	.LFBB3:
 197               	/* prologue: function */
 198               	/* frame size = 0 */
 199               	/* stack size = 0 */
 200               	.L__stack_usage = 0
 201               	.L10:
  34:util.c        ****   while (s--) {
 203               	.LM13:
 204 002c 8823      		tst r24
 205 002e 01F0      		breq .L12
 206               	.LBB4:
 207               	.LBB5:
 209               	.Ltext1:
   1:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** /* $Id: delay.h.in 2385 2013-05-03 13:14:20Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #endif
  41:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  42:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  46:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** /** \file */
  47:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     \code
  49:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     \endcode
  53:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  54:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     used.
  58:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  59:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  68:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  77:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  81:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** */
  82:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #endif
  87:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  88:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #endif
  93:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  94:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #endif
  97:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
  98:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #endif
 103:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 104:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** /**
 105:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 107:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 109:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 112:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 114:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 120:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 125:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 132:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 140:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****  */
 141:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** void
 142:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** {
 144:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 155:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 158:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 	#else
 159:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 	#endif
 162:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 
 163:/usr/local/Cellar/avr-gcc/4.9.3/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 211               	.LM14:
 212 0030 2FEF      		ldi r18,lo8(3199999)
 213 0032 33ED      		ldi r19,hi8(3199999)
 214 0034 90E3      		ldi r25,hlo8(3199999)
 215 0036 2150      		1: subi r18,1
 216 0038 3040      		sbci r19,0
 217 003a 9040      		sbci r25,0
 218 003c 01F4      		brne 1b
 219 003e 00C0      		rjmp .
 220 0040 0000      		nop
 221 0042 8150      		subi r24,lo8(-(-1))
 222 0044 00C0      		rjmp .L10
 223               	.L12:
 224               	/* epilogue start */
 225               	.LBE5:
 226               	.LBE4:
 228               	.Ltext2:
  35:util.c        ****     _delay_ms(1000);
  36:util.c        ****   }
  37:util.c        **** }
 230               	.LM15:
 231 0046 0895      		ret
 233               	.Lscope3:
 235               		.stabd	78,0,0
 238               	.global	uart_putchar
 240               	uart_putchar:
 241               		.stabd	46,0,0
  38:util.c        **** 
  39:util.c        **** // Some uart functions for debugging help
  40:util.c        **** int uart_putchar(char c)
  41:util.c        **** {
 243               	.LM16:
 244               	.LFBB4:
 245               	/* prologue: function */
 246               	/* frame size = 0 */
 247               	/* stack size = 0 */
 248               	.L__stack_usage = 0
 249               	.L14:
  42:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 251               	.LM17:
 252 0048 9091 C000 		lds r25,192
 253 004c 95FF      		sbrs r25,5
 254 004e 00C0      		rjmp .L14
  43:util.c        ****   UDR0 = c;
 256               	.LM18:
 257 0050 8093 C600 		sts 198,r24
  44:util.c        ****   return 0;
  45:util.c        **** }
 259               	.LM19:
 260 0054 80E0      		ldi r24,0
 261 0056 90E0      		ldi r25,0
 262 0058 0895      		ret
 264               	.Lscope4:
 266               		.stabd	78,0,0
 268               	.global	uart_getchar
 270               	uart_getchar:
 271               		.stabd	46,0,0
  46:util.c        **** 
  47:util.c        **** char uart_getchar(void) {
 273               	.LM20:
 274               	.LFBB5:
 275               	/* prologue: function */
 276               	/* frame size = 0 */
 277               	/* stack size = 0 */
 278               	.L__stack_usage = 0
 279               	.L18:
  48:util.c        ****   while (!(UCSR0A & _BV(RXC0)));
 281               	.LM21:
 282 005a 8091 C000 		lds r24,192
 283 005e 87FF      		sbrs r24,7
 284 0060 00C0      		rjmp .L18
  49:util.c        ****   return UDR0;
 286               	.LM22:
 287 0062 8091 C600 		lds r24,198
  50:util.c        **** }
 289               	.LM23:
 290 0066 0895      		ret
 292               	.Lscope5:
 294               		.stabd	78,0,0
 296               	.global	uart_getch
 298               	uart_getch:
 299               		.stabd	46,0,0
  51:util.c        **** 
  52:util.c        **** char uart_getch(void) {
 301               	.LM24:
 302               	.LFBB6:
 303               	/* prologue: function */
 304               	/* frame size = 0 */
 305               	/* stack size = 0 */
 306               	.L__stack_usage = 0
  53:util.c        ****   return (UCSR0A & _BV(RXC0));
 308               	.LM25:
 309 0068 8091 C000 		lds r24,192
  54:util.c        **** }
 311               	.LM26:
 312 006c 8078      		andi r24,lo8(-128)
 313 006e 0895      		ret
 315               	.Lscope6:
 317               		.stabd	78,0,0
 321               	.global	ROM_putstring
 323               	ROM_putstring:
 324               		.stabd	46,0,0
  55:util.c        **** 
  56:util.c        **** void ROM_putstring(const char *str, uint8_t nl) {
 326               	.LM27:
 327               	.LFBB7:
 328 0070 FF92      		push r15
 329 0072 0F93      		push r16
 330 0074 1F93      		push r17
 331 0076 CF93      		push r28
 332 0078 DF93      		push r29
 333 007a 1F92      		push __zero_reg__
 334 007c CDB7      		in r28,__SP_L__
 335 007e DEB7      		in r29,__SP_H__
 336               	/* prologue: function */
 337               	/* frame size = 1 */
 338               	/* stack size = 6 */
 339               	.L__stack_usage = 6
 340 0080 8C01      		movw r16,r24
  57:util.c        ****   uint8_t i;
  58:util.c        **** 
  59:util.c        ****   for (i = 0; pgm_read_byte(&str[i]); i++) {
 342               	.LM28:
 343 0082 F12C      		mov r15,__zero_reg__
 344               	.L22:
 345               	.LBB6:
 347               	.LM29:
 348 0084 F801      		movw r30,r16
 349 0086 EF0D      		add r30,r15
 350 0088 F11D      		adc r31,__zero_reg__
 351               	/* #APP */
 352               	 ;  59 "util.c" 1
 353 008a 9491      		lpm r25, Z
 354               		
 355               	 ;  0 "" 2
 356               	/* #NOAPP */
 357               	.LBE6:
 358 008c 9923      		tst r25
 359 008e 01F0      		breq .L25
 360               	.LBB7:
  60:util.c        ****     uart_putchar(pgm_read_byte(&str[i]));
 362               	.LM30:
 363               	/* #APP */
 364               	 ;  60 "util.c" 1
 365 0090 8491      		lpm r24, Z
 366               		
 367               	 ;  0 "" 2
 368               	/* #NOAPP */
 369               	.LBE7:
 370 0092 6983      		std Y+1,r22
 371 0094 0E94 0000 		call uart_putchar
  59:util.c        ****     uart_putchar(pgm_read_byte(&str[i]));
 373               	.LM31:
 374 0098 F394      		inc r15
 375 009a 6981      		ldd r22,Y+1
 376 009c 00C0      		rjmp .L22
 377               	.L25:
  61:util.c        ****   }
  62:util.c        ****   if (nl) {
 379               	.LM32:
 380 009e 6623      		tst r22
 381 00a0 01F0      		breq .L21
  63:util.c        ****     uart_putchar('\n'); uart_putchar('\r');
 383               	.LM33:
 384 00a2 8AE0      		ldi r24,lo8(10)
 385 00a4 0E94 0000 		call uart_putchar
 386 00a8 8DE0      		ldi r24,lo8(13)
 387               	/* epilogue start */
  64:util.c        ****   }
  65:util.c        **** }
 389               	.LM34:
 390 00aa 0F90      		pop __tmp_reg__
 391 00ac DF91      		pop r29
 392 00ae CF91      		pop r28
 393 00b0 1F91      		pop r17
 394 00b2 0F91      		pop r16
 395 00b4 FF90      		pop r15
  63:util.c        ****     uart_putchar('\n'); uart_putchar('\r');
 397               	.LM35:
 398 00b6 0C94 0000 		jmp uart_putchar
 399               	.L21:
 400               	/* epilogue start */
 402               	.LM36:
 403 00ba 0F90      		pop __tmp_reg__
 404 00bc DF91      		pop r29
 405 00be CF91      		pop r28
 406 00c0 1F91      		pop r17
 407 00c2 0F91      		pop r16
 408 00c4 FF90      		pop r15
 409 00c6 0895      		ret
 417               	.Lscope7:
 419               		.stabd	78,0,0
 422               	.global	uart_puts
 424               	uart_puts:
 425               		.stabd	46,0,0
  66:util.c        **** 
  67:util.c        **** void uart_puts(const char* str)
  68:util.c        **** {
 427               	.LM37:
 428               	.LFBB8:
 429 00c8 CF93      		push r28
 430 00ca DF93      		push r29
 431               	/* prologue: function */
 432               	/* frame size = 0 */
 433               	/* stack size = 2 */
 434               	.L__stack_usage = 2
 435 00cc EC01      		movw r28,r24
 436               	.L27:
  69:util.c        ****   while (*str)
 438               	.LM38:
 439 00ce 8991      		ld r24,Y+
 440 00d0 8823      		tst r24
 441 00d2 01F0      		breq .L29
  70:util.c        ****     uart_putc(*str++);
 443               	.LM39:
 444 00d4 0E94 0000 		call uart_putchar
 445 00d8 00C0      		rjmp .L27
 446               	.L29:
 447               	/* epilogue start */
  71:util.c        **** }
 449               	.LM40:
 450 00da DF91      		pop r29
 451 00dc CF91      		pop r28
 452 00de 0895      		ret
 454               	.Lscope8:
 456               		.stabd	78,0,0
 459               	.global	uart_putc_hex
 461               	uart_putc_hex:
 462               		.stabd	46,0,0
  72:util.c        **** 
  73:util.c        **** 
  74:util.c        **** void uart_putc_hex(uint8_t b)
  75:util.c        **** {
 464               	.LM41:
 465               	.LFBB9:
 466 00e0 CF93      		push r28
 467               	/* prologue: function */
 468               	/* frame size = 0 */
 469               	/* stack size = 1 */
 470               	.L__stack_usage = 1
 471 00e2 C82F      		mov r28,r24
  76:util.c        ****   /* upper nibble */
  77:util.c        ****   if ((b >> 4) < 0x0a)
 473               	.LM42:
 474 00e4 8295      		swap r24
 475 00e6 8F70      		andi r24,lo8(15)
 476 00e8 8A30      		cpi r24,lo8(10)
 477 00ea 00F4      		brsh .L31
  78:util.c        ****     uart_putc((b >> 4) + '0');
 479               	.LM43:
 480 00ec 805D      		subi r24,lo8(-(48))
 481 00ee 00C0      		rjmp .L34
 482               	.L31:
  79:util.c        ****   else
  80:util.c        ****     uart_putc((b >> 4) - 0x0a + 'a');
 484               	.LM44:
 485 00f0 895A      		subi r24,lo8(-(87))
 486               	.L34:
 487 00f2 0E94 0000 		call uart_putchar
  81:util.c        **** 
  82:util.c        ****   /* lower nibble */
  83:util.c        ****   if ((b & 0x0f) < 0x0a)
 489               	.LM45:
 490 00f6 8C2F      		mov r24,r28
 491 00f8 8F70      		andi r24,lo8(15)
 492 00fa 8A30      		cpi r24,lo8(10)
 493 00fc 00F4      		brsh .L33
  84:util.c        ****     uart_putc((b & 0x0f) + '0');
 495               	.LM46:
 496 00fe 805D      		subi r24,lo8(-(48))
 497 0100 00C0      		rjmp .L35
 498               	.L33:
  85:util.c        ****   else
  86:util.c        ****     uart_putc((b & 0x0f) - 0x0a + 'a');
 500               	.LM47:
 501 0102 895A      		subi r24,lo8(-(87))
 502               	.L35:
 503               	/* epilogue start */
  87:util.c        **** }
 505               	.LM48:
 506 0104 CF91      		pop r28
  86:util.c        **** }
 508               	.LM49:
 509 0106 0C94 0000 		jmp uart_putchar
 511               	.Lscope9:
 513               		.stabd	78,0,0
 515               	.global	uart_putw_hex
 517               	uart_putw_hex:
 518               		.stabd	46,0,0
  88:util.c        **** 
  89:util.c        **** void uart_putw_hex(uint16_t w)
  90:util.c        **** {
 520               	.LM50:
 521               	.LFBB10:
 522 010a CF93      		push r28
 523               	/* prologue: function */
 524               	/* frame size = 0 */
 525               	/* stack size = 1 */
 526               	.L__stack_usage = 1
 527 010c C82F      		mov r28,r24
  91:util.c        ****   uart_putc_hex((uint8_t) (w >> 8));
 529               	.LM51:
 530 010e 892F      		mov r24,r25
 531 0110 0E94 0000 		call uart_putc_hex
  92:util.c        ****   uart_putc_hex((uint8_t) (w & 0xff));
 533               	.LM52:
 534 0114 8C2F      		mov r24,r28
 535               	/* epilogue start */
  93:util.c        **** }
 537               	.LM53:
 538 0116 CF91      		pop r28
  92:util.c        ****   uart_putc_hex((uint8_t) (w & 0xff));
 540               	.LM54:
 541 0118 0C94 0000 		jmp uart_putc_hex
 543               	.Lscope10:
 545               		.stabd	78,0,0
 548               	.global	uart_putdw_hex
 550               	uart_putdw_hex:
 551               		.stabd	46,0,0
  94:util.c        **** 
  95:util.c        **** void uart_putdw_hex(uint32_t dw)
  96:util.c        **** {
 553               	.LM55:
 554               	.LFBB11:
 555 011c CF92      		push r12
 556 011e DF92      		push r13
 557 0120 EF92      		push r14
 558 0122 FF92      		push r15
 559               	/* prologue: function */
 560               	/* frame size = 0 */
 561               	/* stack size = 4 */
 562               	.L__stack_usage = 4
 563 0124 6B01      		movw r12,r22
 564 0126 7C01      		movw r14,r24
  97:util.c        ****   uart_putw_hex((uint16_t) (dw >> 16));
 566               	.LM56:
 567 0128 C701      		movw r24,r14
 568 012a 0E94 0000 		call uart_putw_hex
  98:util.c        ****   uart_putw_hex((uint16_t) (dw & 0xffff));
 570               	.LM57:
 571 012e C601      		movw r24,r12
 572               	/* epilogue start */
  99:util.c        **** }
 574               	.LM58:
 575 0130 FF90      		pop r15
 576 0132 EF90      		pop r14
 577 0134 DF90      		pop r13
 578 0136 CF90      		pop r12
  98:util.c        ****   uart_putw_hex((uint16_t) (dw & 0xffff));
 580               	.LM59:
 581 0138 0C94 0000 		jmp uart_putw_hex
 583               	.Lscope11:
 585               		.stabd	78,0,0
 588               	.global	uart_putw_dec
 590               	uart_putw_dec:
 591               		.stabd	46,0,0
 100:util.c        **** 
 101:util.c        **** void uart_putw_dec(uint16_t w)
 102:util.c        **** {
 593               	.LM60:
 594               	.LFBB12:
 595 013c AF92      		push r10
 596 013e BF92      		push r11
 597 0140 CF92      		push r12
 598 0142 DF92      		push r13
 599 0144 EF92      		push r14
 600 0146 FF92      		push r15
 601 0148 0F93      		push r16
 602 014a 1F93      		push r17
 603 014c CF93      		push r28
 604 014e DF93      		push r29
 605 0150 1F92      		push __zero_reg__
 606 0152 CDB7      		in r28,__SP_L__
 607 0154 DEB7      		in r29,__SP_H__
 608               	/* prologue: function */
 609               	/* frame size = 1 */
 610               	/* stack size = 11 */
 611               	.L__stack_usage = 11
 612 0156 7C01      		movw r14,r24
 614               	.LM61:
 615 0158 05E0      		ldi r16,lo8(5)
 616 015a 10E0      		ldi r17,0
 103:util.c        ****   uint16_t num = 10000;
 104:util.c        ****   uint8_t started = 0;
 618               	.LM62:
 619 015c 20E0      		ldi r18,0
 103:util.c        ****   uint16_t num = 10000;
 621               	.LM63:
 622 015e 80E1      		ldi r24,lo8(16)
 623 0160 A82E      		mov r10,r24
 624 0162 87E2      		ldi r24,lo8(39)
 625 0164 B82E      		mov r11,r24
 626               	.LBB8:
 105:util.c        **** 
 106:util.c        ****   while (num > 0)
 107:util.c        ****   {
 108:util.c        ****     uint8_t b = w / num;
 109:util.c        ****     if (b > 0 || started || num == 1)
 110:util.c        ****     {
 111:util.c        ****       uart_putc('0' + b);
 112:util.c        ****       started = 1;
 113:util.c        ****     }
 114:util.c        ****     w -= b * num;
 115:util.c        **** 
 116:util.c        ****     num /= 10;
 628               	.LM64:
 629 0166 9AE0      		ldi r25,lo8(10)
 630 0168 C92E      		mov r12,r25
 631 016a D12C      		mov r13,__zero_reg__
 632               	.L41:
 108:util.c        ****     if (b > 0 || started || num == 1)
 634               	.LM65:
 635 016c C701      		movw r24,r14
 636 016e B501      		movw r22,r10
 637 0170 0E94 0000 		call __udivmodhi4
 109:util.c        ****     {
 639               	.LM66:
 640 0174 6111      		cpse r22,__zero_reg__
 641 0176 00C0      		rjmp .L39
 109:util.c        ****     {
 643               	.LM67:
 644 0178 2111      		cpse r18,__zero_reg__
 645 017a 00C0      		rjmp .L39
 109:util.c        ****     {
 647               	.LM68:
 648 017c 81E0      		ldi r24,1
 649 017e A816      		cp r10,r24
 650 0180 B104      		cpc r11,__zero_reg__
 651 0182 01F4      		brne .L40
 652               	.L39:
 111:util.c        ****       started = 1;
 654               	.LM69:
 655 0184 80E3      		ldi r24,lo8(48)
 656 0186 860F      		add r24,r22
 657 0188 6983      		std Y+1,r22
 658 018a 0E94 0000 		call uart_putchar
 112:util.c        ****     }
 660               	.LM70:
 661 018e 21E0      		ldi r18,lo8(1)
 662 0190 6981      		ldd r22,Y+1
 663               	.L40:
 114:util.c        **** 
 665               	.LM71:
 666 0192 6A9D      		mul r22,r10
 667 0194 C001      		movw r24,r0
 668 0196 6B9D      		mul r22,r11
 669 0198 900D      		add r25,r0
 670 019a 1124      		clr __zero_reg__
 671 019c E81A      		sub r14,r24
 672 019e F90A      		sbc r15,r25
 674               	.LM72:
 675 01a0 C501      		movw r24,r10
 676 01a2 B601      		movw r22,r12
 677 01a4 0E94 0000 		call __udivmodhi4
 678 01a8 5B01      		movw r10,r22
 679 01aa 0150      		subi r16,1
 680 01ac 1109      		sbc r17,__zero_reg__
 681               	.LBE8:
 106:util.c        ****   {
 683               	.LM73:
 684 01ae 01F4      		brne .L41
 685               	/* epilogue start */
 117:util.c        ****   }
 118:util.c        **** }
 687               	.LM74:
 688 01b0 0F90      		pop __tmp_reg__
 689 01b2 DF91      		pop r29
 690 01b4 CF91      		pop r28
 691 01b6 1F91      		pop r17
 692 01b8 0F91      		pop r16
 693 01ba FF90      		pop r15
 694 01bc EF90      		pop r14
 695 01be DF90      		pop r13
 696 01c0 CF90      		pop r12
 697 01c2 BF90      		pop r11
 698 01c4 AF90      		pop r10
 699 01c6 0895      		ret
 705               	.Lscope12:
 707               		.stabd	78,0,0
 710               	.global	uart_put_dec
 712               	uart_put_dec:
 713               		.stabd	46,0,0
 119:util.c        **** 
 120:util.c        **** void uart_put_dec(int8_t w)
 121:util.c        **** {
 715               	.LM75:
 716               	.LFBB13:
 717 01c8 CF92      		push r12
 718 01ca DF92      		push r13
 719 01cc EF92      		push r14
 720 01ce FF92      		push r15
 721 01d0 0F93      		push r16
 722 01d2 1F93      		push r17
 723 01d4 CF93      		push r28
 724 01d6 DF93      		push r29
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 8 */
 728               	.L__stack_usage = 8
 729 01d8 C82F      		mov r28,r24
 122:util.c        ****   uint16_t num = 100;
 123:util.c        ****   uint8_t started = 0;
 124:util.c        **** 
 125:util.c        ****   if (w < 0 ) {
 731               	.LM76:
 732 01da 87FF      		sbrs r24,7
 733 01dc 00C0      		rjmp .L44
 126:util.c        ****     uart_putc('-');
 735               	.LM77:
 736 01de 8DE2      		ldi r24,lo8(45)
 737 01e0 0E94 0000 		call uart_putchar
 127:util.c        ****     w *= -1;
 739               	.LM78:
 740 01e4 C195      		neg r28
 741               	.L44:
 121:util.c        ****   uint16_t num = 100;
 743               	.LM79:
 744 01e6 83E0      		ldi r24,lo8(3)
 745 01e8 E82E      		mov r14,r24
 746 01ea F12C      		mov r15,__zero_reg__
 747 01ec 20E0      		ldi r18,0
 748 01ee 04E6      		ldi r16,lo8(100)
 749 01f0 10E0      		ldi r17,0
 750               	.LBB9:
 128:util.c        ****   }
 129:util.c        ****   while (num > 0)
 130:util.c        ****   {
 131:util.c        ****     int8_t b = w / num;
 132:util.c        ****     if (b > 0 || started || num == 1)
 133:util.c        ****     {
 134:util.c        ****       uart_putc('0' + b);
 135:util.c        ****       started = 1;
 136:util.c        ****     }
 137:util.c        ****     w -= b * num;
 138:util.c        **** 
 139:util.c        ****     num /= 10;
 752               	.LM80:
 753 01f2 9AE0      		ldi r25,lo8(10)
 754 01f4 C92E      		mov r12,r25
 755 01f6 D12C      		mov r13,__zero_reg__
 756               	.L47:
 131:util.c        ****     if (b > 0 || started || num == 1)
 758               	.LM81:
 759 01f8 8C2F      		mov r24,r28
 760 01fa 9927      		clr r25
 761 01fc 87FD      		sbrc r24,7
 762 01fe 9095      		com r25
 763 0200 B801      		movw r22,r16
 764 0202 0E94 0000 		call __udivmodhi4
 765 0206 D62F      		mov r29,r22
 132:util.c        ****     {
 767               	.LM82:
 768 0208 1616      		cp __zero_reg__,r22
 769 020a 04F0      		brlt .L45
 132:util.c        ****     {
 771               	.LM83:
 772 020c 2111      		cpse r18,__zero_reg__
 773 020e 00C0      		rjmp .L45
 132:util.c        ****     {
 775               	.LM84:
 776 0210 0130      		cpi r16,1
 777 0212 1105      		cpc r17,__zero_reg__
 778 0214 01F4      		brne .L46
 779               	.L45:
 134:util.c        ****       started = 1;
 781               	.LM85:
 782 0216 80E3      		ldi r24,lo8(48)
 783 0218 8D0F      		add r24,r29
 784 021a 0E94 0000 		call uart_putchar
 135:util.c        ****     }
 786               	.LM86:
 787 021e 21E0      		ldi r18,lo8(1)
 788               	.L46:
 137:util.c        **** 
 790               	.LM87:
 791 0220 D09F      		mul r29,r16
 792 0222 C019      		sub r28,r0
 793 0224 1124      		clr __zero_reg__
 795               	.LM88:
 796 0226 C801      		movw r24,r16
 797 0228 B601      		movw r22,r12
 798 022a 0E94 0000 		call __udivmodhi4
 799 022e 8B01      		movw r16,r22
 800 0230 81E0      		ldi r24,1
 801 0232 E81A      		sub r14,r24
 802 0234 F108      		sbc r15,__zero_reg__
 803               	.LBE9:
 129:util.c        ****   {
 805               	.LM89:
 806 0236 01F4      		brne .L47
 807               	/* epilogue start */
 140:util.c        ****   }
 141:util.c        **** }
 809               	.LM90:
 810 0238 DF91      		pop r29
 811 023a CF91      		pop r28
 812 023c 1F91      		pop r17
 813 023e 0F91      		pop r16
 814 0240 FF90      		pop r15
 815 0242 EF90      		pop r14
 816 0244 DF90      		pop r13
 817 0246 CF90      		pop r12
 818 0248 0895      		ret
 824               	.Lscope13:
 826               		.stabd	78,0,0
 829               	.global	uart_putdw_dec
 831               	uart_putdw_dec:
 832               		.stabd	46,0,0
 142:util.c        **** 
 143:util.c        **** void uart_putdw_dec(uint32_t dw)
 144:util.c        **** {
 834               	.LM91:
 835               	.LFBB14:
 836 024a 4F92      		push r4
 837 024c 5F92      		push r5
 838 024e 6F92      		push r6
 839 0250 7F92      		push r7
 840 0252 8F92      		push r8
 841 0254 9F92      		push r9
 842 0256 AF92      		push r10
 843 0258 BF92      		push r11
 844 025a CF92      		push r12
 845 025c DF92      		push r13
 846 025e EF92      		push r14
 847 0260 FF92      		push r15
 848 0262 0F93      		push r16
 849 0264 1F93      		push r17
 850 0266 CF93      		push r28
 851 0268 DF93      		push r29
 852               	/* prologue: function */
 853               	/* frame size = 0 */
 854               	/* stack size = 16 */
 855               	.L__stack_usage = 16
 856 026a 4B01      		movw r8,r22
 857 026c 5C01      		movw r10,r24
 859               	.LM92:
 860 026e CAE0      		ldi r28,lo8(10)
 861 0270 D0E0      		ldi r29,0
 145:util.c        ****   uint32_t dw_prime = dw;
 146:util.c        ****   uint32_t num = 1000000000;
 147:util.c        ****   uint8_t started = 0;
 863               	.LM93:
 864 0272 00E0      		ldi r16,0
 146:util.c        ****   uint8_t started = 0;
 866               	.LM94:
 867 0274 C12C      		mov r12,__zero_reg__
 868 0276 8AEC      		ldi r24,lo8(-54)
 869 0278 D82E      		mov r13,r24
 870 027a 8AE9      		ldi r24,lo8(-102)
 871 027c E82E      		mov r14,r24
 872 027e 8BE3      		ldi r24,lo8(59)
 873 0280 F82E      		mov r15,r24
 874               	.LBB10:
 148:util.c        **** 
 149:util.c        ****   while (num > 0) {
 150:util.c        ****     uint8_t b = dw_prime / num;
 151:util.c        ****     if (b > 0 || started || num == 1)
 152:util.c        ****     {
 153:util.c        ****       uart_putc('0' + b);
 154:util.c        ****       started = 1;
 155:util.c        ****     }
 156:util.c        ****     dw_prime = dw_prime - (b * num);
 157:util.c        **** 
 158:util.c        ****     num = num / 10;
 876               	.LM95:
 877 0282 9AE0      		ldi r25,lo8(10)
 878 0284 492E      		mov r4,r25
 879 0286 512C      		mov r5,__zero_reg__
 880 0288 612C      		mov r6,__zero_reg__
 881 028a 712C      		mov r7,__zero_reg__
 882               	.L52:
 150:util.c        ****     if (b > 0 || started || num == 1)
 884               	.LM96:
 885 028c C501      		movw r24,r10
 886 028e B401      		movw r22,r8
 887 0290 A701      		movw r20,r14
 888 0292 9601      		movw r18,r12
 889 0294 0E94 0000 		call __udivmodsi4
 890 0298 122F      		mov r17,r18
 151:util.c        ****     {
 892               	.LM97:
 893 029a 2111      		cpse r18,__zero_reg__
 894 029c 00C0      		rjmp .L50
 151:util.c        ****     {
 896               	.LM98:
 897 029e 0111      		cpse r16,__zero_reg__
 898 02a0 00C0      		rjmp .L50
 151:util.c        ****     {
 900               	.LM99:
 901 02a2 81E0      		ldi r24,1
 902 02a4 C816      		cp r12,r24
 903 02a6 D104      		cpc r13,__zero_reg__
 904 02a8 E104      		cpc r14,__zero_reg__
 905 02aa F104      		cpc r15,__zero_reg__
 906 02ac 01F4      		brne .L51
 907               	.L50:
 153:util.c        ****       started = 1;
 909               	.LM100:
 910 02ae 80E3      		ldi r24,lo8(48)
 911 02b0 810F      		add r24,r17
 912 02b2 0E94 0000 		call uart_putchar
 154:util.c        ****     }
 914               	.LM101:
 915 02b6 01E0      		ldi r16,lo8(1)
 916               	.L51:
 156:util.c        **** 
 918               	.LM102:
 919 02b8 A12F      		mov r26,r17
 920 02ba B0E0      		ldi r27,0
 921 02bc A701      		movw r20,r14
 922 02be 9601      		movw r18,r12
 923 02c0 0E94 0000 		call __muluhisi3
 924 02c4 861A      		sub r8,r22
 925 02c6 970A      		sbc r9,r23
 926 02c8 A80A      		sbc r10,r24
 927 02ca B90A      		sbc r11,r25
 929               	.LM103:
 930 02cc C701      		movw r24,r14
 931 02ce B601      		movw r22,r12
 932 02d0 A301      		movw r20,r6
 933 02d2 9201      		movw r18,r4
 934 02d4 0E94 0000 		call __udivmodsi4
 935 02d8 6901      		movw r12,r18
 936 02da 7A01      		movw r14,r20
 937 02dc 2197      		sbiw r28,1
 938               	.LBE10:
 149:util.c        ****     uint8_t b = dw_prime / num;
 940               	.LM104:
 941 02de 01F4      		brne .L52
 942               	/* epilogue start */
 159:util.c        ****   }
 160:util.c        **** }...
 944               	.LM105:
 945 02e0 DF91      		pop r29
 946 02e2 CF91      		pop r28
 947 02e4 1F91      		pop r17
 948 02e6 0F91      		pop r16
 949 02e8 FF90      		pop r15
 950 02ea EF90      		pop r14
 951 02ec DF90      		pop r13
 952 02ee CF90      		pop r12
 953 02f0 BF90      		pop r11
 954 02f2 AF90      		pop r10
 955 02f4 9F90      		pop r9
 956 02f6 8F90      		pop r8
 957 02f8 7F90      		pop r7
 958 02fa 6F90      		pop r6
 959 02fc 5F90      		pop r5
 960 02fe 4F90      		pop r4
 961 0300 0895      		ret
 967               	.Lscope14:
 969               		.stabd	78,0,0
 971               	.Letext0:
 972               		.ident	"GCC: (GNU) 4.9.3"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:4      *ABS*:000000000000003f __SREG__
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:111    .text:0000000000000000 uart_init
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:147    .text:000000000000001a delay_10us
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:192    .text:000000000000002c delay_s
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:240    .text:0000000000000048 uart_putchar
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:270    .text:000000000000005a uart_getchar
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:298    .text:0000000000000068 uart_getch
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:323    .text:0000000000000070 ROM_putstring
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:424    .text:00000000000000c8 uart_puts
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:461    .text:00000000000000e0 uart_putc_hex
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:517    .text:000000000000010a uart_putw_hex
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:550    .text:000000000000011c uart_putdw_hex
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:590    .text:000000000000013c uart_putw_dec
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:712    .text:00000000000001c8 uart_put_dec
/var/folders/jv/wcsnvvsx27q4dp2b03sf5blh0000gn/T//cc9CdoOl.s:831    .text:000000000000024a uart_putdw_dec

UNDEFINED SYMBOLS
__udivmodhi4
__udivmodsi4
__muluhisi3
